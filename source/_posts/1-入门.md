---
title: 1.入门
date: 2019-06-04 17:59:12
categories: 图形学
tags: 图形学
---



### 渲染流水线

#### 坐标转换依次顺序 

Object space 模型空间 

World space 世界坐标系空间

Eye space 观察坐标系空间

Clip and Project space 屏幕坐标空间

注意： 

1. 光照计算通常在World coordinate space（世界坐标空间）里计算，也可以在Eye space 里计算。
2. 顶点法向量属于Object space ，转化为World space时，要通过（world matrix）转置矩阵的逆矩阵来转换 （复习线性代数去了）

#### Eye Space

以Camera为原点 ，由视线方向、视角和远近平面共同组成一个梯形三维空间，称之为viewing frustum（视锥），超出部分会被裁剪 frustum culling（视锥裁剪）

![](https://i.loli.net/2019/06/04/5cf686f0789c270813.png)

### Project and clip space

因为在不规则的体（viewing frustum）中进行裁剪并非易事，所以应该是先投影再裁剪具体分为三个步骤：

1. 用透视变换矩阵把顶点从视锥体中变换到裁剪空间的CVV中；
2. 在CVV进行图元裁剪；
3. 屏幕映射：将进过前述过程得到的坐标映射到屏幕坐标系上。

- 在第一个步骤里的过程为“投影”，主要投影方法有两种：正交投影和透视投影。
- 只有图元完全或部分存在于视锥内部时才需要光栅化。超出部分进行裁剪。
- 视点去除可以不用在GPU中进行，可以使用高级语言在CPU上实现，提前可减去GPU负担。

#### Primitive Assemble&&Triangle setup

- Primitive Assembly，图元装配，即将顶点根据Primitive（原始的连接关系），还原出网格结构。
- 涉及到三角形的顶点顺序（三角形的法向量朝向）根据右手来决定三角面片的法向量（逆时针排列），法向量朝向视点为正，如果为反面进行背面去除操作（Back-face-Culling）。
- 所有的裁剪剔除都是为了减少需要绘制的顶点个数。
- 裁剪算法主要包括：视域剔除（View Frustum Culing）、背面剔除（Back-Face Culling）、遮挡剔除（Occlusing Culling）和视口裁剪等。

#### 光栅化

目前我们拿到了每个点的屏幕坐标值（Screen coordinate），也知道我们需要绘制的图元（点、线、面）但是有两个问题：

1. 点的屏幕坐标都是浮点数，像素都是由整数表示。（绘制的位置为接近两指定端点的实际线段位置如（10.48，20.51）转化为（10，21）四舍五入 或 加0.5取整）。
2. 在屏幕上需要绘制的有点、线、面，如何根据两个已经确定位置的2个像素点绘制一条线段，如何根据已经确定了位置的3个像素点绘制一个三角形面片。（区域填充推荐慕课课程[大力点击进入](https://www.icourse163.org/course/HUST-1003636001)）

#### Pixel Operation

片元操作：计算出每个像素的颜色值，包括

1. 被遮挡面通过一个被称为深度测试的过程而消除。

2. Texture operatioin，纹理操作，根据像素的纹理坐标，查询对应的纹理值。

3. Blending，混合，根据目前已经画好的颜色，与正在计算的颜色的透明度混合为两种颜色，作为新的颜色输出，通常称之为alpha混合技术。屏幕上的每个像素都关联一个RGB颜色值和一个Z缓冲器深度值，alpha值（可以根据需要生成并存储）。

   从渲染管线得到的RGBA，使用over操作符进行混合：

   ，![](https://i.loli.net/2019/06/05/5cf698001d1b841551.png)

   a是透明度值（alpha）Ca表示透明物体的颜色，Cs表示混合前像素的颜色，Cd为最终计算得到的颜色。

   为了绘制透明物体，需要对物体进行排序，用z buffer 首先绘制不透明物体，然后从后往前混合透明物体。

4. Filtering，将正在算的颜色经过某种Filtering（滤波）后输出，可以理解为：经过一种数学运算变成新的颜色值。（如最近邻滤波和线性滤波)

#### 最终像素的颜色写入帧缓存，过程如下图

![](https://i.loli.net/2019/06/05/5cf69aa2962f261841.png)

